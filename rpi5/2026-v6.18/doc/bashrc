
# ~/.bashrc: executed by bash(1) for non-login shells.
# see /usr/share/doc/bash/examples/startup-files (in the package bash-doc)
# for examples

# If not running interactively, don't do anything
case $- in
    *i*) ;;
      *) return;;
esac

# don't put duplicate lines or lines starting with space in the history.
# See bash(1) for more options
HISTCONTROL=ignoreboth

# append to the history file, don't overwrite it
shopt -s histappend

# for setting history length see HISTSIZE and HISTFILESIZE in bash(1)
HISTSIZE=10000
HISTFILESIZE=20000

# check the window size after each command and, if necessary,
# update the values of LINES and COLUMNS.
shopt -s checkwinsize

# If set, the pattern "**" used in a pathname expansion context will
# match all files and zero or more directories and subdirectories.
#shopt -s globstar

# make less more friendly for non-text input files, see lesspipe(1)
#[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

# set variable identifying the chroot you work in (used in the prompt below)
if [ -z "${debian_chroot:-}" ] && [ -r /etc/debian_chroot ]; then
    debian_chroot=$(cat /etc/debian_chroot)
fi

# set a fancy prompt (non-color, unless we know we "want" color)
case "$TERM" in
    xterm-color|*-256color) color_prompt=yes;;
esac

# uncomment for a colored prompt, if the terminal has the capability; turned
# off by default to not distract the user: the focus in a terminal window
# should be on the output of commands, not on the prompt
force_color_prompt=yes

if [ -n "$force_color_prompt" ]; then
    if [ -x /usr/bin/tput ] && tput setaf 1 >&/dev/null; then
	# We have color support; assume it's compliant with Ecma-48
	# (ISO/IEC-6429). (Lack of such support is extremely rare, and such
	# a case would tend to support setf rather than setaf.)
	color_prompt=yes
    else
	color_prompt=
    fi
fi

if [ "$color_prompt" = yes ]; then
    PS1='${debian_chroot:+($debian_chroot)}\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w \$\[\033[00m\] '
else
    PS1='${debian_chroot:+($debian_chroot)}\u@\h:\w\$ '
fi
unset color_prompt force_color_prompt

# If this is an xterm set the title to user@host:dir
case "$TERM" in
xterm*|rxvt*)
    PS1="\[\e]0;${debian_chroot:+($debian_chroot)}\u@\h: \w\a\]$PS1"
    ;;
*)
    ;;
esac

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    test -r ~/.dircolors && eval "$(dircolors -b ~/.dircolors)" || eval "$(dircolors -b)"
    alias ls='ls --color=auto'
    #alias dir='dir --color=auto'
    #alias vdir='vdir --color=auto'

    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

# colored GCC warnings and errors
#export GCC_COLORS='error=01;31:warning=01;35:note=01;36:caret=01;32:locus=01:quote=01'

# some more ls aliases
#alias ll='ls -l'
#alias la='ls -A'
#alias l='ls -CF'

# Alias definitions.
# You may want to put all your additions into a separate file like
# ~/.bash_aliases, instead of adding them here directly.
# See /usr/share/doc/bash-doc/examples in the bash-doc package.

if [ -f ~/.bash_aliases ]; then
    . ~/.bash_aliases
fi

# enable programmable completion features (you don't need to enable
# this, if it's already enabled in /etc/bash.bashrc and /etc/profile
# sources /etc/bash.bashrc).
if ! shopt -oq posix; then
  if [ -f /usr/share/bash-completion/bash_completion ]; then
    . /usr/share/bash-completion/bash_completion
  elif [ -f /etc/bash_completion ]; then
    . /etc/bash_completion
  fi
fi

# parameter 1 = seconds to capture
check_retrans() {
#  date
# R=$(tshark -Y "tcp.analysis.retransmission" -Tfields -e ip.src -e ip.dst -i eth0 -a duration:$1 2>&1)
# R=$(tshark -Y "tcp.analysis.retransmission" -Tfields -e ip.src -e ip.dst -r ~/pcaps/strm-bad.pcap  2>&1)
#  R=$(tshark -z expert -Y "_ws.expert.severity== error" -Tfields -e ip.src -e ip.dst  -i eth0 -a duration:$1 2>&1)
#  R=$( tshark -z expert                                  -Tfields -e ip.src -e tcp.srcport -e ip.dst -e tcp.dstport -i eth0 -a duration:$1 2>&1)
  R=$( tshark -q -z expert -i $IF -a duration:$1 2>&1)
  echo "$R" | egrep -v '^Capturing on|^0 packets captured' | \
    egrep -v "Previous segment\(s\) not captured|ACKed segment that wasn't captured|Connection finish \(FIN\)| Connection establish request \(SYN\)|Connection establish acknowledge \(SYN\+ACK\)" | \
    egrep -v  "^Chats \(|^\s+Frequency|^===" | \
    egrep -v  "Capture started|File:.*pcapng"
#  date
}

#####

IF=eth0

check_retrans 1 | egrep --color '[0-9]+|'&

#/opt/vc/bin/vcgencmd measure_temp
echo -n Uptime: $(uptime|sed 's/.*up\s\+//')
echo ""
echo -n "Page Size: " ; getconf PAGESIZE

#echo ""
#egrep ^arm_freq /boot/config.txt | awk -F '=' '{print "CPU Frequency: "$2" MHz"}' | egrep --color '[0-9]+ MHz'
egrep ^arm_freq /boot/config.txt | egrep --color '[0-9]+'

sensors | egrep --color=no ^temp | egrep --color '\s\+[0-9].*'
echo -n "CPU frequency: "
expr `vcgencmd measure_clock arm|sed 's/^.*=//'` / 1000000 | egrep --color '.*'


echo -n "${IF} speed:  "
ethtool $IF 2>/dev/null| grep --color=no Speed: | sed 's/\s\+/ /g' | egrep --color '[0-9].*'
echo -n "${IF} issues:  "
E=$(/sbin/ethtool -S $IF | egrep 'err|fail|drop' | egrep -v ': 0$' | tr -d \\n  | sed 's/^\s\+//' | sed 's/$/\n/')
echo "$E"
ethtool -S $IF | egrep -v ': 0$'  | egrep --color '.*error.*|.*drop.*|.*fail.*'
#E=""
#[[ -z "$E" ]] && echo "none"
#echo ""
#/usr/sbin/ifconfig eth0 | grep errors
/usr/sbin/ifconfig $IF | grep errors | egrep '[1-9]'


#iperf3 -p 31337 -c 192.168.0.9 --time 5 --bidir | tail -n 6 | head -n 4
#ssh -o ConnectTimeout=1 -o ConnectionAttempts=1 maniac@192.168.0.9 "iperf3 -p 31337 --server --daemon --one-off" && iperf3 -p 31337 -c 192.168.0.9 --time 5 --bidir | tail -n 6 | head -n 4

echo -n "USB audio:    "
#U=$(sudo lsusb -vd 20b1:2004 | head -n 50 | grep -A 50 'Configuration Descriptor:' | grep -A 2  'bmAttributes' | tail -n2 | sed 's/^\s*//')
#U=$(sudo lsusb -vd 2616:0202 | head -n 50 | grep -A 50 'Configuration Descriptor:' | grep -A 2  'bmAttributes' | tail -n2 | sed 's/^\s*//')
U=$(sudo lsusb -vd 20b1:2004 | head -n 50 | grep -A 50 'Configuration Descriptor:' | grep -A 2  'bmAttributes' | tail -n2 | sed 's/^\s*//')

echo "$U" | tr \\n \| | sed 's/|$//' | sed 's/|/ | /g' | sed 's/\s\+/ /g'
echo ""

echo -n "Isolated CPUs: "
C=$(cat /sys/devices/system/cpu/isolated)
if [ -z "$C" ] ; then
  echo "none"
else
  echo "$C"
fi

pstree

echo -n "iperf3 downl: PLEASE WAIT..."
# sleep hashed out as we do not want to see iperf3 traffic there
#sleep 3   # give tshark time to startup
sleep 0.6
I=$(ssh -o ConnectTimeout=1 -o ConnectionAttempts=1 maniac@192.168.0.9 "iperf3 -p 31337 --server --daemon --one-off" && iperf3 -p 31337 -c 192.168.0.9 --time 1 | egrep sender | awk '{print $7" "$8" , Retr:"$9}' )
##I=$(ssh -o ConnectTimeout=1 -o ConnectionAttempts=1 maniac@192.168.0.9 "iperf3 -p 31337 --server --daemon --one-off" && iperf3 -p 31337 -c 192.168.0.9 --time 5 --bidir | egrep sender | awk '{print $7" "$8" , Retr:"$9} ')
echo -n -e "\b\b\b\b\b\b\b\b\b\b\b\b\b\b"
echo "$I" | egrep --color .

echo "TCP stats"
cat /proc/net/netstat | grep -i tcpext | awk '{print $21,$22} '| column -t | egrep --color '[1-9]+|'
netstat -s | egrep -f filter | awk -F ':' '{print $2" "$1}' | sed 's/\s\+/ /g' | sort -nr | egrep --color "[1-9]+|"

echo ""
echo "help: gompd | goupnp| goroon | ./irqtop | ./psthread"
echo -e "tshark finish in \033[1mfew seconds\033[0m starting with # of captured packets and '\033[1m[1]+  Done check_retrans\033[0m'"
echo ""
